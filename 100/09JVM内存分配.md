# JVM内存分配

JVM内存分配需要从类对象实例创建过程开始分析: 包括五个阶段(检查加载,内存分配,空间初始化,对象头设置,对象初始化init)

- 类检查加载: 当虚拟机遇到new指令时,首选检查指令参数能否在运行时常量池中定位到类的符号引用,并检查这个符号引用代表的类是否被加载,解析,初始化过,若没有,则执行相应的加载过程(调用类加载器进行加载);[new指令对应new,对象克隆,对象反序列化等]
- 内存分配: 类检查加载后,为新生对象分配内存;对象所需内存大小在类加载后确定,将指定大小的空间从堆中划分出来给新生对象;(内存分配方法按照内存管理方式划分不同的分配方式)
    - 指针碰撞(Bump the Pointer默认): 堆中内存规整,使用的内存在一边,未使用内存在另外一边,通过中间指针作为分界线;只要将指针向空闲内存移动指定大小(新生对象大小)即可完成内存分配;
    - 空闲列表(Free List): 堆中内存不规整,未使用内存和使用内存交错分布,则虚拟机需要维护一个列表,用于记录内存情况用于分配内存;
    - 两种分配方式存在并发问题(多线程分配内存,出现竞争),JVM提供两种解决方式:
        - CAS: 借助系统级别的CAS指令,采用无锁方式尝试重新内存分配;
        - TLAB(Thread Local Allocation Buffer): 本地线程分配缓冲,jvm尝试将堆内存提前分配一小块内存,每个线程可以直接使用;
- 内存空间初始化: 内存分配后,jvm将分配的内存空间进行初始化即零值设置,保证对象在未执行初始化代码时可用(如int初始化为0等);
- 设置对象头: 在对象头中设置对象的hash码,gc分代年龄以及类的元数据等信息
    - 对象组成: 对象头,实例数据,对齐填充
    - 对象头: mark workd, 类型指针,数组长度(若为数组) 
    - mark word : 对象hash码,gc分代年龄, 锁状态标识,偏向锁标识等;
    - 类型指针: 指向类元数据等信息;
- 初始化: 执行初始化方法,按照开发人员书写代码完成最后初始化工作;

## 对象大小与指针压缩

对象内部结构可以通过org.openjdk.jol:jol-core打印对象内存布局信息,得到对象的大小;
```Java
<dependency>
  <groupId>org.openjdk.jol</groupId>
  <artifactId>jol-core</artifactId>
  <version>xxx</version>
</dependency>
```

为什么要指针压缩?
- 64bit平台的hotspot中使用32指针(内存实际存储按照64位指针)会多出1.5倍内存,使用较大指针在主内存和本地缓存之间进行数据移动,会占用较大带宽,同时GC会承受较大压力;
- 减少64bit平台下内存消耗,启用指针压缩功能;
- jvm中使用32bit的内存指针,最大支持4g,对象指针存入堆内存使用压缩编码指针变为32bit,取到CPU寄存器时解码指针变为35位(32g),可以使jvm使用32位地址支持更大内存;
- jvm在内存小于4g时,直接抛弃高32位地址,使用低位;
- 当堆内存大于32g时,jvm会强制使用64位地址寻址,会出现数据移动占用带宽,GC压力较大,不推荐使用大于32g内存;

## 对象内存分配
对象的内存分配一般使用指针碰撞和空闲列表的方式分配,但随着后续技术优化如逃逸分析等,在对象分配时存在对象并不全部在堆中分布,有栈上分配等情况;

内存分配有栈上分配,TLAB,大对象分配老年代等(基于逃逸分析,标量替换德国);

- 逃逸分析: jvm的优化技术,分析动态作用域,当一个对象在方法内部定义后,它可能被外部方法引用如作为参数传递给其他方法,这种称为方法逃逸;如果能被外部线程访问称为线程逃逸;从不逃逸,方法逃逸,线程逃逸是对象从低到高的逃逸程度;
- 栈上分配: 当逃逸分析认为对象不会发生逃逸时,会优化对象内存分配位置到栈上进行份分配,而非在堆上分配;(可能会使用标量替换)
- 标量替换: 当逃逸分析对象不发生逃逸进行栈上分配时,jvm会对对象进行标量分解,将对象的成员变量拆开使用方法成员变量代替,不会创建真正的对象;(标量即不可分解的变量如基本数据类型)

资料:
- https://juejin.cn/post/6926004500960542727
- https://juejin.cn/post/6947232495242838053
