# JVM垃圾回收
讲到虚拟机的垃圾回收,就需要了解虚拟机的内存分布:(计栈本堆区)
- 程序计数器:唯一不会出现oom的地方(存储执行的指令)
- Java虚拟机栈:由栈帧构成,每个栈帧又是由4个部分组成
    - 局部变量表: 方法内的局部变量(非静态变量 and 形参),运行时变量大小已确定
    - 操作数栈: 需要执行的指令
    - 动态链接: 运行时常量池的符号引用
    - 方法返回地址: 方法的返回地址
- 本地方法栈: 本地方法执行栈(native方法)
- 堆:java堆,存储jvm中绝大部分实例化对象
- 方法区: 内含运行时常量池(包含类编译后生成的各种字面量以及符号引用替换为直接饮用),线程共享区域,存储了类的信息(类名,方法信息,字段信息等),静态变量等;1.8后称为元数据;

注:(oom相关情况)
1. 程序计数器是唯一一个不会出现oom的地方;
2. 栈溢出:Stack Overflow, 循环调用
3. 堆溢出: 对象实例过多,垃圾回收失败(堆中实例占用98%资源,回收比例不到2%);
4. 方法区溢出: 类过多;

垃圾回收一般主要是针对虚拟机的堆来说,堆内存可以划分两部分:
- 新生代
    - eden区(8):对象优先分配
    - survivor区(2): eden区存活对象移动到这里计算年龄
        - s0(1)
        - s1(1)

堆内存垃圾回收过程:
- 新生成对象优先分配到Eden区,Eden区满会触发Minor GC;
- 第一步Minor GC后,会将存活对象转移到s0区,当s0满了会触发Minor GC, s0存活对象移动到s1;当s1满了再次GC,移动到s0;直到年龄达到15或者s0(s1)中相同年龄对象达到内存一半时,大于等于年龄的对象移动到老年代;
- 在发生Minor GC后可能会发生Major GC,这个视垃圾回收器而定;

Full GC触发条件:
- 手动调用System.gc(),会不断执行Full GC;
- 老年代空间不足;
- 方法区空间不足;

资料: https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md

## 垃圾收集器
https://segmentfault.com/a/1190000037547621

针对HotSpot VM的实现,内部GC分为两大类:
- 部分收集(Partial GC):
    - 新生代收集(Minor GC/Young Gc): 只对新生代垃圾收集
    - 老年代收集(Major GC/Old Gc): 只对老年代垃圾收集,一般也会在不同语境中用Major GC指代整堆收集;
    - 混合收集(Mixed GC): 对整个新生代和部分老年代进行垃圾手机
- 整堆收集:(Full GC): 收集整个堆和方法区(元空间)

新生代:
- Serial: 单线程串行收集器,采用复制算法进行垃圾回收(-XX:+UseSerialGC指定垃圾收集器)
- ParNew: 为Serial的多线程版本,多线程并行垃圾收集器(-XX:ParallelGCThreads=xx设置线程数),使用复制算法, 新生代首选垃圾收集器(-XX:+UseParNewGC)
- Parallel Scanvenge: 多线程垃圾收集器,使用复制算法; 关注系统吞吐量,吞吐量=代码运行时间/(代码运行时间+垃圾收集时间)(-XX:+UseParallelGC),1.8默认垃圾收集器
    - -XX:MaxGCPauseMillis: 设置对打垃圾收集挺短时间
    - -XX:GCTimeRation: 设置吞吐量大小,默认99;

老年代:
- CMS: 多线程并发标记清除算法,关注系统停顿时间,追求最短停顿时间;(-XX:+UseConcMarkSweepGC设置老年代;-XX:ConcGCThreads并发线程数)
    - 初始标记: 暂停所有其他线程,根可达算法与Root直接关联对象标记;
    - 并发标记: GC线程与用户线程并行,标记根可达对象;(因用户线程运行,标记对象不完全可信)
    - 重新标记: 暂停用户线程,修正并发标记阶段因用户线程运行导致标记变动部分,停顿时间比初始标记时间长,比并发标记时间短;
    - 并发清除: gc线程与用户线程并行,对未标记对象进行清扫;
- Serial Old: Serial单线程串行收集器的老年代版本,单线程收集器;使用标记整理算法;
- Parallel Old: 多线程并行垃圾收集器,也是关注垃圾手机吞吐量;(-XX:+UseParallelOldGC老年代使用该算法), 使用标记整理算法;

G1垃圾收集器

ZGC收集器: 复制算法

注: 根可达性分析算法中根(root)包含: 
- Java虚拟机栈(栈帧中局部变量)引用对象;
- 本地方法栈(native)引用对象;
- 方法区(元空间)中类静态属性引用对象;
- 方法区(元空间)中常量引用对象;
- 同步锁持有对象;

## 垃圾回收算法
- 标记-清除算法: 分为标记和清除阶段,会产生空间碎片问题;
- 复制算法: 将内存分为两部分,当其中一部分使用完后,将存活对象移动到另外一部分,并将第一部分清除回收;会降低内存使用率(只有一半)
- 标记整理算法: 根据老年代特点(对象存活时间长),标记存活对象后,将存活对象向一端移动,并清理回收端边界以外空间内存;
- 分代收集算法: 将内存分为几块如新生代,老年代,并根据不同部分的对象存活特点使用不同的垃圾收集算法;