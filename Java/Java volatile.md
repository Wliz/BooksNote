# volatile(易变的) 关键字
volatile是一种轻量级的同步机制,但并不能保证线程并发安全性（非原子性操作）[Synchronized是重量级的同步机制]

主要作用：
- 使用volatile修饰的变量，保证变量对所有线程的可见性，当一个线程改变变量的值后，新值对其他线程时可以立即的值，普通变量不行；【主要是立即刷回主内存，其他线程从主内存中读取】
- 使用volatile禁止语义重排序，JVM不能优化，在一定程度上降低了代码执行效率

## volatile 能够保证线程间变量可见性，是不是意味着volatile修饰的变量的运算是并发安全的？

显然不是，volatile修饰的变量在各个线程的工作内存中时不存在一致性问题，但是该变量的运算不一定是原子性的，导致volatile修饰的变量的运算在并发下不一定安全；

## volatile和synchronized比较

synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性；

ThreadLocal和synchronized都用于解决多线程并发访问，但两者本质不同：

synchronized用于实现同步机制，利用锁机制使得代码块在某一个时刻只能被一个线程访问，是时间换空间；

ThreadLocal为每一个线程提供一个变量的副本，使得线程在某个时刻访问到的并不是同一个对象，也就不存在变量的共享，是空间换时间；

## ThreadLocal如何解决并发安全？

ThreadLocal为每一个线程提供维护变量的副本，把共享数据的可见范围控制在一个线程内部，实现原理是内部有一个map，存储线程变量的副本；

使用ThreadLocal要注意remove！

因为ThreadLocalMap的可以为ThreadLocal，所以会导致线程结束后内存并不会被回收，必须要等待所有使用该对象的线程执行接触才能回收，容易导致OOM；