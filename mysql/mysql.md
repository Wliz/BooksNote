## MySQL中InnoDb支持的四中事务隔离级别名称，以及区别？

四个级别包括：
- read uncommited:读未提交；事务修改，但没有提交；事务可以读取未提交的数据，脏读；
- read committed:脏读，读已提交，不可重复读；（一个事务在读，另一个事务已提交，会导致事务内多次读取数据不一致）
- repeatable read【数据库默认事务隔离级别】: 可重复读(保证同一次事务中多次查询的语句结果是一致的)；但可重复读无法避免产生幻行问题（Phantom Row），但通过MVCC解决了幻读问题；
    - 主要是由于多线程开启事务会导致；
- serializable: 串行事务：避免幻读，会在读取的每一行数据加锁，导致当量大量的所等待和超时问题，实际环境很少使用；


链接：https://juejin.im/post/6844903805822173198

## 事务基本要素ACID

- 原子性（Atomicity）：事务开始后的操作，要么全做，要么全不做；
- 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏；
- 隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同事务之间彼此没有干扰；
- 持久性（Durability）：事务完成后，事务对数据库的所有更新被保存到数据库，不能回滚；

注：原子性是事务隔离的基础，隔离性和持久性是手段，最终目的是为了保持数据的一致性；

## 事务并发问题

- 脏读：读未提交，多事务读取回滚之前数据，脏数据；指一个线程中的事务读取到另外一个线程中未提交的数据；
- 不可重复读：事务A多次读取统一数据不一致（因为事务B更新数据）；一个线程中的事务读取到另外一个线程提交的更新数据；
- 幻读：多次读取数据不一致；如一个事务在更新，一个事务在插入，导致部分数据未更新；指一个线程事务读取到另外一个线程提交的insert数据；

注：不可重复度和幻读很容易混淆，不可重复度侧重于修改，幻读侧重于新增或删除；解决不可重复读需要锁行，幻读需要锁表；

mysql默认事务隔离级别（可重复读）并不会锁住读取的行；

## char和varchar存储和检索区别？

char是固定长度，长度范围在1-255；char存储时被使用空格填充到指定长度；

varchar是可变长度的字符类型；将实际内容存储在聚簇索引之外，内容开头用1-2个字节表示实际长度（超过255需要2个字节），最大长度不得超过65535；

## like和regexp区别

like有两个模式_【表示单个字符】和%【表示0个或多个字符】；

regexp正则匹配，使用BINARY表示区分大小写；

## 数据库三大范式

- 第一范式：数据库的每个字段都是不可分割的；
- 第二范式：数据库表中的非主属性只依赖主键；
- 第三范式：不存在非主属性对关键字的函数依赖关系；

## mysql有那种几种锁？

MyIsam支持表锁，innodb支持表锁和行锁，默认行锁；

表级锁：开销小，加锁快，不会出现死锁。锁定粒度打，发生锁冲突概率最高，并发量低；

行级锁：开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突概率小，并发度搞；

## mysql常用索引？

- 普通索引
- 唯一索引
- 主键索引
- 组合索引

## mysql复制原理以及流程？

一个服务器充当主机，其他服务器充当从服务器。主服务器将更新写进二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器在日志中读取到最后一个成功更新的位置，从服务器接收从那时起发生的更新，并等待主服务器通知新的更新；

过程：
- 主服务器将更新记录到二进制日志文件中
- 从服务器把主服务的二进制日志拷贝到自己的中继日志文件中
- 从服务器重做中继日志中的时间，把更新引用到自己的数据库上

## mysql支持的复制类型？
1. 基于语句复制（默认）：在主服务器上执行的sql语句，在从服务器上重新执行一次；
2. 基于行的复制：把改变的内容复制过去，不是把命令在从服务器上执行一遍；
3. 混合类型的复制，默认采用基于语句的复制，一旦发现基于语句的无法精确复制，就会采取基于行的复制；

## mysql中innodb引擎的行锁通过加在什么上完成实现？

innodb行锁是通过给索引上的索引项加锁实现的；同时也意味着只有通过索引条件检索数据，innodb才使用行锁，否则使用表锁；

## 一张表中只有一个字段varchar(n)类型，utf-8编码，n的最大值多少？

utf-8的每个字符最多占用三个字节，mysql一行长度不能超过16k(65535)；

n = (65535 -1 -2)/3;

减一代表实际存储从第二个字节开始；减去二是要在列表长度存储字符串的实际长度

## select * 与select 全部字段有何优缺点？
- 前者要解析数据字段，后者不需要解析
- 结果输出前者按照建表顺序，后者按照指定顺序
- 后者可以索引优化，前者不行
- 后者可读性好

## having和where异同？
- where + 字段名，having+结果别名
- where可以使用索引，having无法使用索引
- where 不能使用聚集函数，having可以使用聚集函数

## mysql试题

### 一张表有id，自增，当id插入15，16，17三条数据后，删除15，16，17后，重启mysql，再插入一条数据，新增数据id多少？是18还是15？

- 如果是myisam，是18，因为会把主键记录到数据文件，重启不丢失数据；
- 如果是innodb，是15，innodb将自增主键id存储在内存中；

### 列为auto increment时，表值达到足底啊，会发生什么情况？

停止递增，任何进一步的插入都会报错；

### 可以使用多少列创建索引？

任何标准表最多可以创建16个索引列；